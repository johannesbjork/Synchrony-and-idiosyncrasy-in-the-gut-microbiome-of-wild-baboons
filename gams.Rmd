---
title: "Generalized Additive Models (GAMs)"
author: Johannes Björk
output: html_notebook
---

Before starting, I want to point out four terrific GAM resources which have greatly helped me along the way.

1. **[Pederson et al. (2019)](https://peerj.com/articles/6876/) Hierarchical generalized additive models in ecology: an introduction with mgcv**
2. **[Simon Wood's book](https://www.amazon.com/Generalized-Additive-Models-Introduction-Statistical/dp/1498728332) Generalized additive models: an introduction with R**
3. **[Gavin Simpson's blog](https://www.fromthebottomoftheheap.net) which contains a lot of GAM tips**
4. **[Stack Overflow](https://stackoverflow.com/questions/tagged/gam) -- most questions you may have, someone has already had before you! Gavin Simpson and others provide many informative answers to a great deal of GAM related questions.**

We first load the phyloseq object which contains metadata, an ASV table, and the corresponding taxonomy. In the metadata, you will see that I have already added the first three principal components (PCs). These come from a PCA of clr-transformed relative abundances. The euclidean distance between samples within the clr space is called the Aitchison distance, which is the perfered distance when your data is relative counts (so-called compositional data) which is the case for high-throughput sequences (you can find the code for the PCA analysis in the repository). In the metadata, you will also find three alpha diversity indices--Species Richness (richness), Shannon entropy (shannon) and the inverse Simpson index (simpson) which I computed using the `hillR::hill_taxa(...,q=)` function where `q` specifies the hill number (i.e. `q=0` for Richness, `q=1` for Shannon, and `q=2` for Simpson). 

Apart from this, you will also see several covariates at the population, group and host level. At the population level, we have monthly and annual total rainfall and maximum temperature. Here, all samples in the same time point have the same values of rain and temperature. At the social group level, we have group size, longitude and latitude, total home range area, fraction unique home range area, and 13 different diet PCs. Note that these covariates are at the resolution of the social groups'. This means that in any given time point, all samples from the same group have the same values. At the host level, we you will see sex, age and social rank. Here, all samples from a given individual and time point have the same values. 

We'll start using `PC1`-`PC3` and the alpha diversity indices as response variables in our GAMs. However, to manage residual autocorrelation, we'll run a AR(1) procsses of these variables, and use the residuals of this process as the actual response. To do so, we use the `arima(...,order=c(1,0,0)` function. This will reduce the temporal dependency of the most immediate samples. However, before running the `arima()` function, we have to make the time series continuous by "filling in" any missing dates with NAs. We do this with the `padr:pad()` function.    

We then subset this, the population-level time series, to a group-level time series (containing the 5 main groups), which we subseqently subset to a host-level dataset (only containing the 13 best-sampled hosts). We do this subsetting as we are asking more of our GAMs at every level: at the group level, above population level processes, we are also trying to infer group-specific trends (smooths) over time. Similarly, at the host level, we are, above population and group level processes, trying to infer host-specific smooths. If we include hosts or groups with only a few samples across several years, there's not a lot of data to robustly estimate any trends from. However, in order to assure that differences in data size and model complexity don't affect our conclusions, we run several "sanity checks" (see XXX documents).     

#### Load packages and data 

```{r}
library(phyloseq)
library(tidyverse)
library(patchwork)
library(mgcv)
library(gratia)
library(knitr)
library(kableExtra)
library(broom.mixed)
```

```{r, echo=T, eval=T, message=FALSE, warning=FALSE}

# Load phyloseq object
ps <- readRDS("~/Documents/Projects/baboonWorld/metagenomics_baboons/submission/ps.RDS")

metadata <- as(sample_data(ps), "data.frame") # convert metadata to a data.frame  

metadata <- metadata %>%
  padr::pad("day") %>%
  mutate(PC1_AR=arima(PC1, order=c(1,0,0))$residuals,
         PC2_AR=arima(PC2, order=c(1,0,0))$residuals,
         PC3_AR=arima(PC3, order=c(1,0,0))$residuals,
         richness_AR=arima(richness, order=c(1,0,0))$residuals,
         shannon_AR=arima(shannon, order=c(1,0,0))$residuals,
         simpson_AR=arima(simpson, order=c(1,0,0))$residuals,
         grp=factor(grp), 
         host=factor(host),
         time=as.integer(factor(collection_date)),
         month=factor(months(collection_date, abbreviate=T), levels=c("Nov","Dec","Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct")),
         month_int=as.numeric(month),
         season=factor(season))


metadata_grp <- metadata %>% 
  filter(grp %in% c("1.1","1.21","1.22","2.1","2.2"), collection_date <= "2011-10-27") %>%
  mutate(grp=factor(grp), 
         host=factor(host),
         time=as.integer(factor(collection_date)))
 
# metadata_grp %>%
#   group_by(host) %>%
#   count() %>%
#   arrange(desc(n))

# We selected the 13 best-sampled hosts, excluding Baboon_259 as most of its samples where located at the end of the time period.  

select_host <- c("Baboon_498","Baboon_103","Baboon_494","Baboon_503","Baboon_4","Baboon_390","Baboon_113","Baboon_283","Baboon_395","Baboon_382","Baboon_481","Baboon_107","Baboon_78")

metadata_host <- metadata_grp %>%
  filter(host %in% select_host) %>%
  mutate(grp=factor(grp), 
         host=factor(host),
         sex=factor(sex),
         time=as.integer(factor(collection_date)))
```

### Fitting the models
As we attempt to model up >17,000 samples (at the populaton level), we fitted our models with the `bam()` function from the `R` package `mgcv`, which uses fast restricted maximum likelihood (`method=”fREML”`) as the smoothing parameter estimation method. Model 2 (eq. 2: P+G) and 3 (eq. 3: P+G+H) are close analogues to varying slopes linear mixed models, where social groups and hosts, respectively, have similar functional responses but variation within each grouping variable is allowed. More specifically, each grouping level is allowed its own functional response, but functions that are farther from the average are penalized more heavily. This was achieved by using factor smooths (`bs=”fs”`) which restrict each level of the grouping variable to have the same wiggliness by creating a copy of each set of basis functions while estimating one smoothing parameter for all groupings. To further shrink all components of each smoother toward zero effect, we set `select=TRUE`. This option penalizes both the wiggly functions and the functions in the null space (i.e. functions without derivatives, e.g. intercept and linear terms), thus effectively performing a model selection similar to LASSO. 

#### Choosing the basis dimension
The wiggliness of a smooth is determined by the effective degrees of freedom (`EDF`), which are controlled by the degree of regularization/penalization selected during fitting (e.g. by `method=”REML”`). As stated in `?mgcv::choose.k()` the “(...) exact choice of k is not generally critical: it should be chosen to be large enough that you are reasonably sure of having enough degrees of freedom to represent the underlying ‘truth’ reasonably well, but small enough to maintain reasonable computational efficiency.” 

For eq. 1: P, the cyclic intra-annual smooth `(bs=”cc”)`, `k=7` to strike a balance between the degrees of freedom and computation (the maximum k=12 would be too high). Similarly, for the inter-annual smooth, k is set to an intermediate value; for eq. 1: P k is set to 8 (the maximum value is `k=14`), and for eqs. 2-3 `k` is set to 6 (the maximum value is `k=12`). For the `s(time, group)` and `s(time, host)` in eq. 2: P+G and eq. 3: P+G+H, `k` is set to 50 and 30, respectively, which is relatively low given that the maximum values are in the hundreds. 

Finally, not directly related to the choice of basis dimensions, the `m` parameter specifies the order of the penalty for a smooth term: `m=2` is the default for many basis functions, but for multilevel GAMs with nested global and group-level smoothers, it is recommended to set `m` equal to 1 for the group-level smoother. This will penalize the squared first rather than the squared second derivative, and a group-level smoother with `m=1` will have a more restricted null space, ultimately reducing collinearity with the global smoother. 

```{r, echo=T, eval=T, message=FALSE, warning=FALSE}

# Model 1 - PC1
f1_pc1 <- as.formula(PC1_AR~
                         s(month_int, k=7, bs="cc") +
                         s(hydro_year, k=8, bs="fs") +
                         s(rain_monthly) + 
                         s(rain_annual) +
                         s(tempmax_monthly) +
                         s(tempmax_annual))

# Model 2 - PC1
f2_pc1 <- as.formula(PC1_AR~
                       s(month_int, k=7, bs="cc") + 
                       s(hydro_year, k=6, bs="fs", m=2) + 
                       s(time, grp, k=50, bs="fs", m=1) + 
                       s(group_size) + 
                       s(area_tot_sqkm) + 
                       s(frac_uniq) + 
                       s(lat, lon, time) + 
                       s(diet_PC1) + 
                       s(diet_PC2) + 
                       s(diet_PC3) + 
                       s(diet_PC4) + 
                       s(diet_PC5) + 
                       s(diet_PC6) + 
                       s(diet_PC7) + 
                       s(diet_PC8) + 
                       s(diet_PC9) + 
                       s(diet_PC10) +
                       s(diet_PC11) +
                       s(diet_PC12) +
                       s(diet_PC13))

# Model 3 - PC1
f3_pc1 <- as.formula(PC1_AR~
                       s(month_int, k=7, bs="cc") + 
                       s(hydro_year, k=6, bs="fs", m=2) + 
                       s(time, grp, k=50, bs="fs", m=2) + 
                       s(time, host, k=30, bs="fs", m=1) + 
                       s(age) + 
                       s(sex, bs="re") + 
                       s(proportional_rank))


# Model 1 - Shannon entropy
f1_shannon <- as.formula(shannon_AR~
                         s(month_int, k=7, bs="cc") +
                         s(hydro_year, k=8, bs="fs") +
                         s(rain_monthly) + 
                         s(rain_annual) +
                         s(tempmax_monthly) +
                         s(tempmax_annual))

# Model 2 - Shannon entropy
f2_shannon <- as.formula(shannon_AR~
                       s(month_int, k=7, bs="cc") + 
                       s(hydro_year, k=6, bs="fs", m=2) + 
                       s(time, grp, k=50, bs="fs", m=1) + 
                       s(group_size) + 
                       s(area_tot_sqkm) + 
                       s(frac_uniq) + 
                       s(lat, lon, time) + 
                       s(diet_PC1) + 
                       s(diet_PC2) + 
                       s(diet_PC3) + 
                       s(diet_PC4) + 
                       s(diet_PC5) + 
                       s(diet_PC6) + 
                       s(diet_PC7) + 
                       s(diet_PC8) + 
                       s(diet_PC9) + 
                       s(diet_PC10) +
                       s(diet_PC11) +
                       s(diet_PC12) +
                       s(diet_PC13))

# Model 3 - Shannon entropy
f3_shannon <- as.formula(shannon_AR~
                       s(month_int, k=7, bs="cc") + 
                       s(hydro_year, k=6, bs="fs", m=2) + 
                       s(time, grp, k=50, bs="fs", m=2) + 
                       s(time, host, k=30, bs="fs", m=1) + 
                       s(age) + 
                       s(sex, bs="re") + 
                       s(proportional_rank))

# Fit models
m1_pc1 <- bam(f1_pc1, data=metadata, select=T)
m2_pc1 <- bam(f2_pc1, data=metadata_grp, select=T)
m3_pc1 <- bam(f3_pc1, data=metadata_host, select=T)

m1_shannon <- bam(f1_shannon, data=metadata, select=T)
m2_shannon <- bam(f2_shannon, data=metadata_grp, select=T)
m3_shannon <- bam(f3_shannon, data=metadata_host, select=T)
```

Below we plot summary tables for each model using the `summary()` function. The function prints `EDF`, `Ref.df`, the `F` statistic, and the `p-value` for the focal smooth term. It also shows you the % `deviance explained` which is identical to the unadjusted `R^2` for linear models. The color scheme depicts the focal smoother's significance (or importance if you will) in explaining the dynamics of the response variable: the darker the green, the lower the `p-value` (this mimics Fig. 2 in the main text).    

### Microbiome PC1

```{r, echo=T, eval=T, message=FALSE, warning=FALSE, results="asis"}
summary(m1_pc1)$s.table %>% 
  kable(digits=3, format="html", booktabs=T) %>% 
  kable_styling(font_size=12, full_width=F, latex_options=c("striped", "hold_position")) %>% 
  group_rows(start_row=1, end_row=4,  paste0("Deviance explained: ",round(summary(m1_pc1)$dev.expl*100,2),"%")) %>%
  add_footnote("Model: eq. 1 (P) | Response variable: PC1", escape=FALSE, notation="none") %>%
  row_spec(which(summary(m1_pc1)$s.table[,4] <= 0.001), bold = T, color="black", background="#219647") %>%
  row_spec(which(summary(m1_pc1)$s.table[,4] <= 0.001), bold = T, color="black", background="#219647") %>% 
  row_spec(which(summary(m1_pc1)$s.table[,4] > 0.001 & summary(m1_pc1)$s.table[,4] <= 0.01), bold = T, color="black", background="#67be67") %>% 
  row_spec(which(summary(m1_pc1)$s.table[,4] > 0.01 & summary(m1_pc1)$s.table[,4] <= 0.05), bold = T, color="black", background="#9dd2a1")

summary(m2_pc1)$s.table %>% kable(digits=3, format="html", booktabs=T) %>% 
  kable_styling(font_size=12, full_width=F, latex_options=c("striped", "hold_position")) %>% 
  group_rows(start_row=1, end_row=4,  paste0("Deviance explained: ",round(summary(m2_pc1)$dev.expl*100,2),"%")) %>% 
  add_footnote("Model: eq. 2 (P+G) | Response variable: PC1", escape=FALSE, notation="none") %>%
  row_spec(which(summary(m2_pc1)$s.table[,4] <= 0.001), bold = T, color="black", background="#219647") %>% 
  row_spec(which(summary(m2_pc1)$s.table[,4] > 0.001 & summary(m2_pc1)$s.table[,4] <= 0.01), bold = T, color="black", background="#67be67") %>% 
  row_spec(which(summary(m2_pc1)$s.table[,4] > 0.01 & summary(m2_pc1)$s.table[,4] <= 0.05), bold = T, color="black", background="#9dd2a1")

summary(m3_pc1)$s.table %>% kable(digits=3, format="html", booktabs=T) %>% 
  kable_styling(font_size=12, full_width=F, latex_options=c("striped", "hold_position")) %>% 
  group_rows(start_row=1, end_row=4,  paste0("Deviance explained: ",round(summary(m3_pc1)$dev.expl*100,2),"%")) %>% 
  add_footnote("Model: eq. 3 (P+G+H) | Response variable: PC1", escape=FALSE, notation="none") %>% 
  row_spec(which(summary(m3_pc1)$s.table[,4] <= 0.001), bold = T, color="black", background="#219647") %>% 
  row_spec(which(summary(m3_pc1)$s.table[,4] > 0.001 & summary(m3_pc1)$s.table[,4] <= 0.01), bold = T, color="black", background="#67be67") %>% 
  row_spec(which(summary(m3_pc1)$s.table[,4] > 0.01 & summary(m3_pc1)$s.table[,4] <= 0.05), bold = T, color="black", background="#9dd2a1")
```

### Shannon entropy

```{r, echo=T, eval=T, message=FALSE, warning=FALSE, results="asis"}
summary(m1_shannon)$s.table %>% kable(digits=3, format="html", booktabs=T) %>% kable_styling(font_size=12, full_width=F, latex_options=c("striped", "hold_position")) %>% group_rows(start_row=1, end_row=4,  paste0("Deviance explained: ",round(summary(m1_shannon)$dev.expl*100,2),"%")) %>% add_footnote("Model: eq. 1 (P) | Response variable: Shannon entropy", escape=FALSE, notation="none") %>% row_spec(which(summary(m1_shannon)$s.table[,4] <= 0.001), bold = T, color="black", background="#219647") %>% row_spec(which(summary(m1_shannon)$s.table[,4] <= 0.001), bold = T, color="black", background="#219647") %>% 
  row_spec(which(summary(m1_shannon)$s.table[,4] > 0.001 & summary(m1_shannon)$s.table[,4] <= 0.01), bold = T, color="black", background="#67be67") %>% 
  row_spec(which(summary(m1_shannon)$s.table[,4] > 0.01 & summary(m1_shannon)$s.table[,4] <= 0.05), bold = T, color="black", background="#9dd2a1")

summary(m2_shannon)$s.table %>% kable(digits=3, format="html", booktabs=T) %>% 
  kable_styling(font_size=12, full_width=F, latex_options=c("striped", "hold_position")) %>% group_rows(start_row=1, end_row=4,  paste0("Deviance explained: ",round(summary(m2_shannon)$dev.expl*100,2),"%")) %>% 
  add_footnote("Model: eq. 2 (P+G) | Response variable: Shannon entropy", escape=FALSE, notation="none") %>%
  row_spec(which(summary(m2_shannon)$s.table[,4] <= 0.001), bold = T, color="black", background="#219647") %>% 
  row_spec(which(summary(m2_shannon)$s.table[,4] > 0.001 & summary(m2_shannon)$s.table[,4] <= 0.01), bold = T, color="black", background="#67be67") %>% 
  row_spec(which(summary(m2_shannon)$s.table[,4] > 0.01 & summary(m2_shannon)$s.table[,4] <= 0.05), bold = T, color="black", background="#9dd2a1")

summary(m3_shannon)$s.table %>% kable(digits=3, format="html", booktabs=T) %>% kable_styling(font_size=12, full_width=F, latex_options=c("striped", "hold_position")) %>% group_rows(start_row=1, end_row=4,  paste0("Deviance explained: ",round(summary(m3_shannon)$dev.expl*100,2),"%")) %>% add_footnote("Model: eq. 3 (P+G+H) | Response variable: Shannon entropy", escape=FALSE, notation="none") %>% 
  row_spec(which(summary(m3_shannon)$s.table[,4] <= 0.001), bold = T, color="black", background="#219647") %>% 
  row_spec(which(summary(m3_shannon)$s.table[,4] > 0.001 & summary(m3_shannon)$s.table[,4] <= 0.01), bold = T, color="black", background="#67be67") %>% 
  row_spec(which(summary(m3_shannon)$s.table[,4] > 0.01 & summary(m3_shannon)$s.table[,4] <= 0.05), bold = T, color="black", background="#9dd2a1")
```

However, it is important to evaluate model fit. We first do so from generating two different diagnostic plots. The first plot (on the right hand side) is a QQ-plot of the residuals where the red line indicating the 1–1 line and gray bands correspond to the expected 95% CI (assuming the distribution is correct). The QQ-plots below indicate that the normal distribution fit the observed data well. The second type of plot (on the left hand side) plots the deviance residuals versus the fitted values which is to identify heteroscedasticity of the residuals. In the below plots we don't see any patterns in the residuals, which indicate good model fit.

### Model diagnostics for microbiome PC1
```{r, echo=T, eval=T, message=FALSE, warning=FALSE}
# QQ-plots from gratia's qq_plot function with simulated confidence intervals
qq_m1_pc1 <- qq_plot(m1_pc1, method="simulate") + labs(title=NULL, subtitle=NULL) + theme(panel.background=element_blank(), panel.grid.major=element_blank(), panel.grid.minor=element_blank())

qq_m2_pc1 <- qq_plot(m2_pc1, method="simulate") + labs(title=NULL, subtitle=NULL) + theme(panel.background=element_blank(), panel.grid.major=element_blank(), panel.grid.minor=element_blank())

qq_m3_pc1 <- qq_plot(m3_pc1, method="simulate") + labs(title=NULL, subtitle=NULL) + theme(panel.background=element_blank(), panel.grid.major=element_blank(), panel.grid.minor=element_blank())

# Deviance residuals vs fitted values
dev_vs_fit_m1_pc1 <- data.frame(fitted=fitted(m1_pc1), residuals=resid(m1_pc1, type="deviance")) %>%
  ggplot(aes(x=fitted, y=residuals)) + geom_point() + labs(x="Linear predictor", y="Deviance residual") + theme(panel.background=element_blank(),panel.grid.major=element_blank(), panel.grid.minor=element_blank())

dev_vs_fit_m2_pc1 <- data.frame(fitted=fitted(m2_pc1), residuals=resid(m2_pc1, type="deviance")) %>%
  ggplot(aes(x=fitted, y=residuals)) + geom_point() + labs(x="Linear predictor", y="Deviance residual") + theme(panel.background=element_blank(),panel.grid.major=element_blank(), panel.grid.minor=element_blank())

dev_vs_fit_m3_pc1 <- data.frame(fitted=fitted(m3_pc1), residuals=resid(m3_pc1, type="deviance")) %>%
  ggplot(aes(x=fitted, y=residuals)) + geom_point() + labs(x="Linear predictor", y="Deviance residual") + theme(panel.background=element_blank(),panel.grid.major=element_blank(), panel.grid.minor=element_blank())

# combine plots using patchwork
(qq_m1_pc1 | dev_vs_fit_m1_pc1) / (qq_m2_pc1 | dev_vs_fit_m2_pc1) / (qq_m3_pc1 | dev_vs_fit_m3_pc1)
```

## Model diagnostics for Shannon entropy
```{r, echo=T, eval=T, message=FALSE, warning=FALSE}
qq_m1_shannon <- qq_plot(m1_shannon, method="simulate") + labs(title=NULL, subtitle=NULL) + theme(panel.background=element_blank(), panel.grid.major=element_blank(), panel.grid.minor=element_blank())

qq_m2_shannon <- qq_plot(m2_shannon, method="simulate") + labs(title=NULL, subtitle=NULL) + theme(panel.background=element_blank(), panel.grid.major=element_blank(), panel.grid.minor=element_blank())

qq_m3_shannon <- qq_plot(m3_shannon, method="simulate") + labs(title=NULL, subtitle=NULL) + theme(panel.background=element_blank(), panel.grid.major=element_blank(), panel.grid.minor=element_blank())

dev_vs_fit_m1_shannon <- data.frame(fitted=fitted(m1_shannon), residuals=resid(m1_shannon, type="deviance")) %>%
  ggplot(aes(x=fitted, y=residuals)) + geom_point() + labs(x="Linear predictor", y="Deviance residual") + theme(panel.background=element_blank(),panel.grid.major=element_blank(), panel.grid.minor=element_blank())

dev_vs_fit_m2_shannon <- data.frame(fitted=fitted(m2_shannon), residuals=resid(m2_shannon, type="deviance")) %>%
  ggplot(aes(x=fitted, y=residuals)) + geom_point() + labs(x="Linear predictor", y="Deviance residual") + theme(panel.background=element_blank(),panel.grid.major=element_blank(), panel.grid.minor=element_blank())

dev_vs_fit_m3_shannon <- data.frame(fitted=fitted(m3_shannon), residuals=resid(m3_shannon, type="deviance")) %>%
  ggplot(aes(x=fitted, y=residuals)) + geom_point() + labs(x="Linear predictor", y="Deviance residual") + theme(panel.background=element_blank(),panel.grid.major=element_blank(), panel.grid.minor=element_blank())

# plot using patchwork
(qq_m1_shannon | dev_vs_fit_m1_shannon) / (qq_m2_shannon | dev_vs_fit_m2_shannon) / (qq_m3_shannon | dev_vs_fit_m3_shannon)
```

To test whether the basis dimension for each smooth term in a model is adequate, we used the `mgcv`’s `k.check()` function. The output is a table showing the maximum degrees of freedom or the number of basis functions (`k'`), the effective degrees of freedom (`EDF`), the `k-index`, and the `p-value` for the observed `k-index` for each smoother in the model. Preferably, the `k-index` ought to be close to 1 which indicates that there is little pattern left in the residuals, and the associated p-value >0.05. Furthermore, if `k'` is very close to the `EDF`, this suggests that the dimension of the basis expansion of `N` for the focal smooth is too small. It is important to note, however, that the output of this test, especially the `p-value`, should be treated as a guide. I have found for some of the response variables that some smooths have a `p-value` > 0.05 even though `k'` is far from `EDF`. See, for example, smooths for model 3 with Shannon entropy as the response variable.

```{r, echo=T, eval=T, message=FALSE, warning=FALSE}
#set.seed(1) # have to set.seed as the p-value is computed from permutations

k.check(m1_pc1)[1:2,] %>% broom.mixed::tidy(effect='fixed') %>% select(".rownames", "k.", "edf", "k.index", "p.value") %>% kable(digits=2, format='html', caption="Model 1 (eq. 1)", booktabs=T, col.names=c("Smooth term", "k'", "EDF", "k-index", "p-value")) %>% kable_styling(font_size=12, full_width=F, latex_options=c("striped", "hold_position")) %>% add_footnote("Response variable: PC1", escape=FALSE, notation="none")

k.check(m2_pc1)[1:3,] %>% broom.mixed::tidy(effect='fixed') %>% select(".rownames", "k.", "edf", "k.index", "p.value") %>% kable(digits=2, format='html', caption="Model 2 (eq. 2)", booktabs=T, col.names=c("Smooth term", "k'", "EDF", "k-index", "p-value")) %>% kable_styling(font_size=12, full_width=F, latex_options=c("striped", "hold_position")) %>% add_footnote("Response variable: PC1", escape=FALSE, notation="none")

k.check(m3_pc1)[1:4,] %>% broom.mixed::tidy(effect='fixed') %>% select(".rownames", "k.", "edf", "k.index", "p.value") %>% kable(digits=2, format='html', caption="Model 3 (eq. 3)", booktabs=T, col.names=c("Smooth term", "k'", "EDF", "k-index", "p-value")) %>% kable_styling(font_size=12, full_width=F, latex_options=c("striped", "hold_position")) %>% add_footnote("Response variable: PC1", escape=FALSE, notation="none")

k.check(m1_shannon)[1:2,] %>% broom.mixed::tidy(effect = 'fixed') %>% select(".rownames", "k.", "edf", "k.index", "p.value") %>% kable(digits=2, format='html', caption="Model 1 (eq. 1)", booktabs=T, col.names=c("Smooth term", "k'", "EDF", "k-index", "p-value")) %>% kable_styling(font_size=12, full_width=F, latex_options=c("striped", "hold_position")) %>% add_footnote("Response variable: Shannon entropy", escape=FALSE, notation="none")

k.check(m2_shannon)[1:3,] %>% broom.mixed::tidy(effect = 'fixed') %>% select(".rownames", "k.", "edf", "k.index", "p.value") %>% kable(digits=2, format='html', caption="Model 2 (eq. 2)", booktabs=T, col.names=c("Smooth term", "k'", "EDF", "k-index", "p-value")) %>% kable_styling(font_size=12, full_width=F, latex_options=c("striped", "hold_position")) %>% add_footnote("Response variable: Shannon entropy", escape=FALSE, notation="none")

k.check(m3_shannon)[1:4,] %>% broom.mixed::tidy(effect = 'fixed') %>% select(".rownames", "k.", "edf", "k.index", "p.value") %>% kable(digits=2, format='html', caption="Model 3 (eq. 3)", booktabs=T, col.names=c("Smooth term", "k'", "EDF", "k-index", "p-value")) %>% kable_styling(font_size=12, full_width=F, latex_options=c("striped", "hold_position")) %>% add_footnote("Response variable: Shannon entropy", escape=FALSE, notation="none")
```

### Residual independence
Lastly, we assess residual independence of each covariate included in each model. We do this by plotting the residuals of the focal model versus each covariate included in the model. The `bam()` functions remove any time point for which there is a `NA` either in the response or covariates. This means that if there are any NAs in the data, you won't be able to plot the residuals against the predictor as the vectors will be of different lengths. Therefore, we have to refit the models adding the NA option `na=gam::na.gam.replace`. As this is a bit tedious, for the purpose of demonstration, we do this for microbiome PC1.
 
```{r, echo=F, eval=T, message=FALSE, warning=FALSE}
# Re-fit models keeping NAs
m1_pc1_keep_na <- bam(f1_pc1, data=metadata, select=T, na=gam::na.gam.replace)
m2_pc1_keep_na <- bam(f2_pc1, data=metadata_grp, select=T, na=gam::na.gam.replace)
m3_pc1_keep_na <- bam(f3_pc1, data=metadata_host, select=T, na=gam::na.gam.replace)
```

```{r, echo=F, eval=T, message=FALSE, warning=FALSE}
par(mfrow=c(3,2), mar=c(3,3,3,3), oma=c(0,0,0,0))
plot(x=metadata[!is.na(metadata$PC1),]$month, y=m1_pc1_keep_na$residuals, las=1, xlab=NA, ylab=NA)
title(xlab="Month", ylab="Residuals", line=1.8, cex.lab=1.2)
plot(x=metadata[!is.na(metadata$PC1),]$hydro_year, y=m1_pc1_keep_na$residuals, las=1, xlab=NA, ylab=NA)
title(xlab="Hydrological year", ylab="Residuals", line=1.8, cex.lab=1.2)
plot(x=metadata[!is.na(metadata$PC1),]$tempmax_monthly, y=m1_pc1_keep_na$residuals, las=1, xlab=NA, ylab=NA)
title(xlab="Monthly tempmax", ylab="Residuals", line=1.8, cex.lab=1.2)
plot(x=metadata[!is.na(metadata$PC1),]$tempmax_annual, y=m1_pc1_keep_na$residuals, las=1, xlab=NA, ylab=NA)
title(xlab="Annual tempmax", ylab="Residuals", line=1.8, cex.lab=1.2)
plot(x=metadata[!is.na(metadata$PC1),]$rain_monthly, y=m1_pc1_keep_na$residuals, las=1, xlab=NA, ylab=NA)
title(xlab="Monthly rainfall", ylab="Residuals", line=1.8, cex.lab=1.2)
plot(x=metadata[!is.na(metadata$PC1),]$rain_annual, y=m1_pc1_keep_na$residuals, las=1, xlab=NA, ylab=NA)
title(xlab="Annual rainfall", ylab="Residuals", line=1.8, cex.lab=1.2)
```

### Model 2 (eq. 2)
```{r, echo=F, eval=T}
# model 2 - PC1
par(mfrow=c(3,2), mar=c(3,3,3,3), oma=c(0,0,0,0))
plot(metadata_grp$lon, m2_pc1_keep_na$residuals)
title(xlab="Longitude", ylab="Residuals", line=1.8, cex.lab=1.2)
plot(metadata_grp$lat, m2_pc1_keep_na$residuals)
title(xlab="Latitude", ylab="Residuals", line=1.8, cex.lab=1.2)
plot(metadata_grp$area_tot_sqkm, m2_pc1_keep_na$residuals)
title(xlab="Home range size (km2)", ylab="Residuals", line=1.8, cex.lab=1.2)
plot(metadata_grp$frac_uniq, m2_pc1_keep_na$residuals)
title(xlab="Fraction home range unique", ylab="Residuals", line=1.8, cex.lab=1.2)
plot(0,type='n',axes=FALSE,ann=FALSE)
plot(0,type='n',axes=FALSE,ann=FALSE)

par(mfrow=c(3,2), mar=c(3,3,3,3), oma=c(0,0,0,0))
plot(metadata_grp$diet_PC1, m2_pc1_keep_na$residuals)
title(xlab="Diet PC1", ylab="Residuals", line=1.8, cex.lab=1.2)
plot(metadata_grp$diet_PC2, m2_pc1_keep_na$residuals)
title(xlab="Diet PC2", ylab="Residuals", line=1.8, cex.lab=1.2)
plot(metadata_grp$diet_PC3, m2_pc1_keep_na$residuals)
title(xlab="Diet PC3", ylab="Residuals", line=1.8, cex.lab=1.2)
plot(metadata_grp$diet_PC4, m2_pc1_keep_na$residuals)
title(xlab="Diet PC4", ylab="Residuals", line=1.8, cex.lab=1.2)
plot(metadata_grp$diet_PC5, m2_pc1_keep_na$residuals)
title(xlab="Diet PC5", ylab="Residuals", line=1.8, cex.lab=1.2)
plot(metadata_grp$diet_PC6, m2_pc1_keep_na$residuals)
title(xlab="Diet PC6", ylab="Residuals", line=1.8, cex.lab=1.2)

par(mfrow=c(4,2), mar=c(3,3,3,3), oma=c(0,0,0,0))
plot(metadata_grp$diet_PC7, m2_pc1_keep_na$residuals)
title(xlab="Diet PC7", ylab="Residuals", line=1.8, cex.lab=1.2)
plot(metadata_grp$diet_PC8, m2_pc1_keep_na$residuals)
title(xlab="Diet PC8", ylab="Residuals", line=1.8, cex.lab=1.2)
plot(metadata_grp$diet_PC9, m2_pc1_keep_na$residuals)
title(xlab="Diet PC9", ylab="Residuals", line=1.8, cex.lab=1.2)
plot(metadata_grp$diet_PC10, m2_pc1_keep_na$residuals)
title(xlab="Diet PC10", ylab="Residuals", line=1.8, cex.lab=1.2)
plot(metadata_grp$diet_PC11, m2_pc1_keep_na$residuals)
title(xlab="Diet PC11", ylab="Residuals", line=1.8, cex.lab=1.2)
plot(metadata_grp$diet_PC12, m2_pc1_keep_na$residuals)
title(xlab="Diet PC12", ylab="Residuals", line=1.8, cex.lab=1.2)
plot(metadata_grp$diet_PC13, m2_pc1_keep_na$residuals)
title(xlab="Diet PC13", ylab="Residuals", line=1.8, cex.lab=1.2)
```

```{r, echo=F, eval=T}
# model 3 - PC1
par(mfrow=c(2,3), mar=c(3,3,7,3), oma=c(0,0,0,0))
plot(metadata_host$age, m3_pc1_keep_na$residuals)
title(ylab="Age", xlab="Residuals", line=1.8, cex.lab=1.2)
plot(metadata_host$proportional_rank, m3_pc1_keep_na$residuals)
title(ylab="Social rank", xlab="Residuals", line=1.8, cex.lab=1.2)
plot(metadata_host$sex, m3_pc1_keep_na$residuals)
title(ylab="Sex", xlab="Residuals", line=1.8, cex.lab=1.2)
plot(0,type='n',axes=FALSE,ann=FALSE)
plot(0,type='n',axes=FALSE,ann=FALSE)
plot(0,type='n',axes=FALSE,ann=FALSE)
```
