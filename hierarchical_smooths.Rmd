---
title: "R Notebook"
author: Johannes Bj√∂rk
output: html_notebook
---

The below code shows how to produce plots showing (1) population level dynamics; (2) group level dynamics, and finally host level dynamics.

```{r, echo=T, eval=T, message=FALSE, warning=FALSE}
library(phyloseq)
library(tidyverse)
library(padr)
library(patchwork)
```

```{r, echo=T, eval=T, message=FALSE, warning=FALSE}
# Load phyloseq object
ps <- readRDS("~/../ps.RDS")

# Extract metadata
metadata <- as(sample_data(ps),"data.frame") %>%
  mutate(time=as.integer(factor(collection_date)))

# Read in rain data
rain_monthly <- readRDS("~/../rain_monthly.RDS")

# Here we pad the time series by filling in missing collection dates with NAs. Becuase we do so, we have to add rain data for those "new" dates. We have rain data on a higher resolution than microbiome samples.
metadata_pad <- metadata %>%
  padr::pad(by="collection_date") %>%
  mutate(time=as.integer(factor(collection_date)),
         month=factor(months(collection_date, abbreviate=T), levels=c("Nov","Dec","Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct")),
         hydro_year=case_when(lubridate::month(collection_date) < 11 ~ lubridate::year(collection_date), lubridate::month(collection_date) >=11 ~ lubridate::year(collection_date)+1),
         season=case_when(lubridate::month(collection_date) %in% c(11,12,1,2,3,4,5) ~ "Wet",
                          lubridate::month(collection_date) %in% 6:10 ~ "Dry")) %>%
  # read in "new" rain data
  dplyr::select(-rain_monthly) %>%
  left_join(rain_monthly, by=c("month", "hydro_year")) %>%
  mutate(month=factor(months(collection_date, abbreviate=T), levels=c("Nov","Dec","Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct")))

# Here we re-code the start and end of the dry season based on the amount of total rainfall in the month(s) before and after it. Dry season is typically from June to October. However, if April and May each had <= 2 mm of rainfall, we re-code April and May as Dry season. Similarly, if June or October each had >= 2 mm, we re-code these as Wet season.   
metadata_pad <- metadata_pad %>% 
  mutate(year_month=paste0(format(collection_date, "%Y"), "_", format(collection_date, "%b"))) %>% 
  mutate(season=if_else(year_month == "2000_Apr", replace(x=season, values="Dry"), season)) %>%
  mutate(season=if_else(year_month == "2000_May", replace(x=season, values="Dry"), season)) %>%
  mutate(season=if_else(year_month == "2002_Oct", replace(x=season, values="Wet"), season)) %>%
  mutate(season=if_else(year_month == "2004_Oct", replace(x=season, values="Wet"), season)) %>%
  mutate(season=if_else(year_month == "2005_Jun", replace(x=season, values="Wet"), season)) %>%
  mutate(season=if_else(year_month == "2005_Oct", replace(x=season, values="Wet"), season)) %>%
  mutate(season=if_else(year_month == "2006_Oct", replace(x=season, values="Wet"), season)) %>%
  mutate(season=if_else(year_month == "2007_Aug", replace(x=season, values="Wet"), season)) %>%
  mutate(season=if_else(year_month == "2007_Sep", replace(x=season, values="Wet"), season)) %>%
  mutate(season=if_else(year_month == "2007_Oct", replace(x=season, values="Wet"), season)) %>%
  mutate(season=if_else(year_month == "2008_Oct", replace(x=season, values="Wet"), season)) %>%
  mutate(season=if_else(year_month == "2009_Jun", replace(x=season, values="Wet"), season)) %>%
  mutate(season=if_else(year_month == "2010_Jun", replace(x=season, values="Wet"), season)) %>%
  mutate(season=if_else(year_month == "2010_Oct", replace(x=season, values="Wet"), season)) %>%
  mutate(season=if_else(year_month == "2011_Oct", replace(x=season, values="Wet"), season)) %>%
  mutate(season=if_else(year_month == "2012_Jun", replace(x=season, values="Wet"), season)) %>%
  mutate(season=if_else(year_month == "2012_Oct", replace(x=season, values="Wet"), season)) %>%
  ungroup() %>% 
  # The above re-coding of wet and dry season also shifts the hydrological year; a hydrological year must always contain a full wet and dry season. 
  mutate(hydro_year=if_else(year_month == "2002_Oct", replace(x=hydro_year, values=2003), hydro_year)) %>% 
  mutate(hydro_year=if_else(year_month == "2004_Oct", replace(x=hydro_year, values=2005), hydro_year)) %>% 
  mutate(hydro_year=if_else(year_month == "2005_Oct", replace(x=hydro_year, values=2006), hydro_year)) %>% 
  mutate(hydro_year=if_else(year_month == "2006_Oct", replace(x=hydro_year, values=2007), hydro_year)) %>% 
  mutate(hydro_year=if_else(year_month == "2007_Aug", replace(x=hydro_year, values=2008), hydro_year)) %>% 
  mutate(hydro_year=if_else(year_month == "2007_Sep", replace(x=hydro_year, values=2008), hydro_year)) %>%
  mutate(hydro_year=if_else(year_month == "2007_Oct", replace(x=hydro_year, values=2008), hydro_year)) %>% 
  mutate(hydro_year=if_else(year_month == "2008_Oct", replace(x=hydro_year, values=2009), hydro_year)) %>% 
  mutate(hydro_year=if_else(year_month == "2010_Oct", replace(x=hydro_year, values=2011), hydro_year)) %>% 
  mutate(hydro_year=if_else(year_month == "2011_Oct", replace(x=hydro_year, values=2012), hydro_year)) %>% 
  mutate(hydro_year=if_else(year_month == "2012_Oct", replace(x=hydro_year, values=2013), hydro_year)) 

# Crate a data.frame to plot panels corresponding to wet and dry season
rect_idx_season <- cbind(  data.frame(hydro_year=rep(unique(metadata_pad$hydro_year), each=2)),
                               data.frame(season=c("Wet","Dry"),stringsAsFactors=F),
                               data.frame(xmin=NA),
                               data.frame(xmax=NA),
                               data.frame(ymin=-Inf),
                               data.frame(ymax=Inf))
rect_idx_season <- rect_idx_season[-1,]

for(n in 1:nrow(rect_idx_season)) {
  print(n)
  rect_idx_season$xmin[n] <- min(metadata_pad[metadata_pad$hydro_year %in% rect_idx_season$hydro_year[n] & metadata_pad$season %in% rect_idx_season$season[n],]$time)
  rect_idx_season$xmax[n] <- max(metadata_pad[metadata_pad$hydro_year %in% rect_idx_season$hydro_year[n] & metadata_pad$season %in% rect_idx_season$season[n],]$time)
}
x_breaks <- rect_idx_season %>% group_by(hydro_year) %>% summarise(min=min(xmin),max=max(xmax))
```

### Population level dynamics
```{r, echo=T, eval=T, message=FALSE, warning=FALSE}
# Here we fit a GAM so we can plot a population level smooth. This can also be done directly in ggplot() using stat_smooth(...,method="gam"). For the purpose of vizualising the population level smooth, we are using a cyclic basis function (bs="cc") to reduce the uncertainty of the smooth in the left and right margin (i.e. starting and end points). 
metadata_pad$PC1_fitted <- NA
metadata_pad$PC1_se.fit <-NA
m_pop_PC1 <- mgcv::gam(PC1 ~ s(time, k=65, bs="cc"), data=metadata_pad)
metadata_pad$PC1_fitted <- mgcv::predict.bam(m_pop_PC1, newdata=metadata_pad[,c("PC1","time")])
metadata_pad$PC1_se.fit <- mgcv::predict.bam(m_pop_PC1, se.fit=T, newdata=metadata_pad[,c("PC1","time")])$se.fit

# Compute 95% CIs
metadata_pad <- metadata_pad %>% 
  mutate(sample_size=n(),
         PC1_lower.ci = PC1_fitted - qt(1 - (0.05 / 2), sample_size - 1) * PC1_se.fit,
         PC1_upper.ci = PC1_fitted + qt(1 - (0.05 / 2), sample_size - 1) * PC1_se.fit) 

p_pop <- metadata_pad %>% 
  ggplot(aes(y=PC1, x=time)) +
  geom_rect(data=rect_idx_season, inherit.aes=FALSE, aes(xmin=xmin, xmax=xmax, ymin=ymin, ymax=ymax, fill=factor(season)), alpha=0.7, show.legend=F) + 
  scale_fill_manual(values = c("#f6e8c3","#7fbf7b")) +
  geom_point(aes(color=factor(season)), size=0.7, alpha=0.5) + 
  scale_color_manual(values = c("#c6c3c1","#efe3d8")) +
  geom_ribbon(aes(ymin=PC1_lower.ci, ymax=PC1_upper.ci), fill="#dddbdb", alpha=0.3) + 
  geom_line(aes(y=PC1_fitted, x=time), color="#ef9050") + 
  xlab(NULL) + 
  ylab("PC1") +
  scale_x_continuous(breaks=x_breaks$min, labels=x_breaks$hydro_year, expand=c(0,0)) +
  theme(panel.grid.major=element_blank(), 
        panel.grid.minor = element_blank(),
        panel.background=element_blank(), 
        axis.ticks.length=unit(0.25,"cm"), 
        axis.title.y=element_text(size=11), 
        axis.title.x=element_text(size=11), 
        axis.text.y=element_text(size=10), 
        axis.text.x=element_text(size=10), 
        axis.line=element_blank()) +
  guides(color=FALSE)

# Plot monthly total rainfall over the same time period
p_pop_rain <- metadata_pad %>% 
  ggplot(aes(x=time, y=rain_monthly)) +
  geom_rect(data=rect_idx_season, inherit.aes=FALSE, aes(xmin=xmin, xmax=xmax, ymin=ymin, ymax=ymax, fill=factor(season)), alpha=0.7, show.legend=F) +
  geom_line(color="#7faed6") +
  labs(x="Hydrological year") +
  ylab("Monthly total rainfall (mm)") +
  scale_fill_manual(values = c("#f6e8c3","#7fbf7b")) +
  scale_x_continuous(breaks=x_breaks$min, labels=x_breaks$hydro_year, expand=c(0,0)) +
  theme(panel.grid.major=element_blank(), 
        panel.grid.minor = element_blank(),
        panel.background=element_blank(), 
        axis.ticks.length=unit(0.25,"cm"), 
        axis.title.y=element_text(size=11), 
        axis.title.x=element_text(size=11), 
        axis.text.y=element_text(size=10), 
        axis.text.x=element_text(size=10), 
        axis.line=element_blank())
  
# Plot using patchwork. Note however, to create Fig. 1B from the main text, I overlayed p1 and p2 in Adobe Illustrator.
p_pop / p_pop_rain
```

#### Intra and inter-annual trends
```{r, echo=T, eval=T, message=FALSE, warning=FALSE}
# Inter-annual trend
inter_dat <- metadata %>% 
  group_by(hydro_year, season) %>%
  mutate(hydro_year_season=factor(paste0(hydro_year,"_",season), levels=c("2000_Wet","2000_Dry","2001_Wet","2001_Dry","2002_Wet","2002_Dry","2003_Wet","2003_Dry","2004_Wet","2004_Dry","2005_Wet","2005_Dry","2006_Wet","2006_Dry","2007_Wet","2007_Dry","2008_Wet","2008_Dry","2009_Wet","2009_Dry","2010_Wet","2010_Dry","2011_Wet","2011_Dry","2012_Wet","2012_Dry","2013_Wet","2013_Dry"))) %>%
  filter(!hydro_year_season %in% "2000_Wet") %>%
  mutate(hydro_time=as.integer(hydro_year_season))

p_inter_annual <- inter_dat %>% 
  ggplot() + 
  geom_boxplot(aes(y=PC1, x=hydro_time, fill=season, group=hydro_year_season), notch = TRUE, size=0.5) +
  stat_smooth(method='gam', formula=y~s(x, k=8), aes(y=PC1, x=hydro_time), size=1.5, se=T, color="#ef9050") +
  scale_fill_manual(values = c("#f6e8c3","#7fbf7b")) +
  scale_color_manual(values = c("#d8b973","#328e2b")) +
  scale_x_continuous(breaks=c(2, seq(3, 28, 2)+0.5), labels=2000:2013, expand=c(0.01, 0.01)) +
  theme(panel.border=element_rect(colour="black", fill=NA, size=0.8), 
        panel.grid.major=element_blank(), 
        panel.grid.minor=element_blank(), 
        panel.background=element_blank(), 
        axis.ticks.length=unit(0.25,"cm"), 
        axis.title.y=element_text(size=11), 
        axis.title.x=element_text(size=11), 
        axis.text.y=element_text(size=10), 
        axis.text.x=element_text(size=10)) +
  guides(color=FALSE, fill=FALSE) + xlab(NULL)

# Total annual rainfall by season 
rain_annual <- rain %>%
  mutate(month=as.character(lubridate::month(collection_date, label=T)),
         hydro_year=case_when(lubridate::month(collection_date) < 11 ~ lubridate::year(collection_date), lubridate::month(collection_date) >=11 ~ lubridate::year(collection_date)+1)) %>%
  mutate(season=case_when(lubridate::month(collection_date) %in% c(11,12,1,2,3,4,5) ~ "Wet",
                          lubridate::month(collection_date) %in% 6:10 ~ "Dry")) %>%
  group_by(season,hydro_year) %>%
  summarise(mean_annual_rain=sum(rain)) %>%
  arrange(hydro_year) %>%
  mutate(hydro_year_season=factor(paste0(hydro_year,"_",season), levels=c("2000_Wet","2000_Dry","2001_Wet","2001_Dry","2002_Wet","2002_Dry","2003_Wet","2003_Dry","2004_Wet","2004_Dry","2005_Wet","2005_Dry","2006_Wet","2006_Dry","2007_Wet","2007_Dry","2008_Wet","2008_Dry","2009_Wet","2009_Dry","2010_Wet","2010_Dry","2011_Wet","2011_Dry","2012_Wet","2012_Dry","2013_Wet","2013_Dry"))) %>%
  filter(!hydro_year_season %in% "2000_Wet") %>%
  mutate(hydro_time=as.integer(hydro_year_season))

p_inter_annual_rain <- rain_annual %>% 
  ggplot(aes(x=hydro_year_season, y=mean_annual_rain)) + 
  geom_line(aes(group=1),color="#7faed6") +
  labs(x="Hydrological year", y="Total annual rainfall by season (mm)") +
  ylim(c(0,600)) +
  theme(panel.border=element_rect(colour="black", fill=NA, size=0.8), 
        panel.grid.major=element_blank(), 
        panel.grid.minor=element_blank(), 
        panel.background=element_blank(), 
        axis.ticks.length=unit(0.25,"cm"), 
        axis.title.y=element_text(size=11), 
        axis.title.x=element_text(size=11), 
        axis.text.y=element_text(size=10), 
        axis.text.x=element_text(size=10, angle = 90, hjust = 1)) +
  guides(color=FALSE, fill=FALSE)
  
# Intra-annual trend
intra_dat <- metadata %>% 
  mutate(month=factor(month,levels=c("Nov","Dec","Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct"))) %>% 
  group_by(month, hydro_year) %>% 
  dplyr::summarize(PC1_mean=mean(PC1, na.rm=TRUE))

intra_dat_rect <- metadata %>% 
  group_by(month) %>% 
  dplyr::summarize(rainfall_mean=mean(rain_monthly)) %>%
  mutate(month=factor(month,levels=c("Nov","Dec","Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct"))) %>%
  arrange(month) %>%
  mutate(xmin=1:12,
         xmax=2:13,
         ymin=-Inf,
         ymax=Inf,
         xmax=car::recode(xmax, "13=NA"))

p_intra_annual <- intra_dat %>%
    ggplot(aes(x=as.integer(month), y=PC1_mean)) +
      geom_rect(data=intra_dat_rect, inherit.aes=FALSE, aes(xmin=xmin, xmax=xmax, ymin=ymin, ymax=ymax, fill=rainfall_mean), alpha=0.7) + 
      scale_fill_gradient(low="white", high="#4292c6") +
      geom_point(color="darkgray", size=1, alpha=1) +
      ylab("PC1 average") + xlab("Months") +
      stat_smooth(method='gam', formula=y~s(x, bs="cc", k=7), aes(y=PC1_mean, x=as.numeric(month)), size=1.5, se=T, color="#ef9050") +
      scale_x_continuous(breaks=1:12, labels=levels(intra_dat_rect$month), expand=c(0,0.1)) + 
      scale_color_manual(values=c("#e41a1c","#f28106","#4745af","#e541c6","#31725b")) +
      guides(fill=guide_legend(title="Average rainfall (mm)"), override.aes=list(size=2), shape=guide_legend(override.aes=list(size=2), keywidth=0.1, keyheight=0.1, default.unit="inch")) +
      theme(panel.border=element_rect(colour="black", fill=NA, size=0.8),
            axis.ticks.length=unit(0.25,"cm"), 
            axis.text.x=element_text(size=10),
            panel.grid.major = element_blank(),
            panel.grid.minor = element_blank())

# Plot using patchwork. Note however, to create Fig. 1B from the main text, I overlayed p1 and p2 in Adobe Illustrator.
(p_inter_annual + p_inter_annual_rain) / (p_intra_annual + plot_spacer())
```

### Group level dynamics
```{r, echo=T, eval=T, message=FALSE, warning=FALSE}
## Group level dynamics
# Subset to group level data
metadata_pad_grp <- metadata %>% 
  filter(grp %in% c("1.1","1.21","1.22","2.1","2.2"), collection_date <= "2011-10-27") %>%
  mutate(grp=factor(grp)) %>%
  group_by(grp) %>%
  padr::pad(by="collection_date", start_val=as.Date("2000-04-21")) %>%
  mutate(time=as.integer(factor(collection_date)),
         month=factor(months(collection_date, abbreviate=T), levels=c("Nov","Dec","Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct")),
         hydro_year=case_when(lubridate::month(collection_date) < 11 ~ lubridate::year(collection_date), lubridate::month(collection_date) >=11 ~ lubridate::year(collection_date)+1),
         season=case_when(lubridate::month(collection_date) %in% c(11,12,1,2,3,4,5) ~ "Wet",
                          lubridate::month(collection_date) %in% 6:10 ~ "Dry")) %>%
  arrange(grp, collection_date) %>%
  ungroup()

metadata_pad_grp <- metadata_pad_grp %>% 
  mutate(year_month=paste0(format(collection_date, "%Y"), "_", format(collection_date, "%b"))) %>% 
  mutate(season=if_else(year_month == "2000_Apr", replace(x=season, values="Dry"), season)) %>%
  mutate(season=if_else(year_month == "2000_May", replace(x=season, values="Dry"), season)) %>%
  mutate(season=if_else(year_month == "2002_Oct", replace(x=season, values="Wet"), season)) %>%
  mutate(season=if_else(year_month == "2004_Oct", replace(x=season, values="Wet"), season)) %>%
  mutate(season=if_else(year_month == "2005_Jun", replace(x=season, values="Wet"), season)) %>%
  mutate(season=if_else(year_month == "2005_Oct", replace(x=season, values="Wet"), season)) %>%
  mutate(season=if_else(year_month == "2006_Oct", replace(x=season, values="Wet"), season)) %>%
  mutate(season=if_else(year_month == "2007_Aug", replace(x=season, values="Wet"), season)) %>%
  mutate(season=if_else(year_month == "2007_Sep", replace(x=season, values="Wet"), season)) %>%
  mutate(season=if_else(year_month == "2007_Oct", replace(x=season, values="Wet"), season)) %>%
  mutate(season=if_else(year_month == "2008_Oct", replace(x=season, values="Wet"), season)) %>%
  mutate(season=if_else(year_month == "2009_Jun", replace(x=season, values="Wet"), season)) %>%
  mutate(season=if_else(year_month == "2010_Jun", replace(x=season, values="Wet"), season)) %>%
  mutate(season=if_else(year_month == "2010_Oct", replace(x=season, values="Wet"), season)) %>%
  mutate(season=if_else(year_month == "2011_Oct", replace(x=season, values="Wet"), season)) %>%
  mutate(season=if_else(year_month == "2012_Jun", replace(x=season, values="Wet"), season)) %>%
  mutate(season=if_else(year_month == "2012_Oct", replace(x=season, values="Wet"), season)) %>%
  ungroup() %>% 
  # The above re-coding of wet and dry season also shifts the hydrological year; a hydrological year must always contain a full wet and dry season. 
  mutate(hydro_year=if_else(year_month == "2002_Oct", replace(x=hydro_year, values=2003), hydro_year)) %>% 
  mutate(hydro_year=if_else(year_month == "2004_Oct", replace(x=hydro_year, values=2005), hydro_year)) %>% 
  mutate(hydro_year=if_else(year_month == "2005_Oct", replace(x=hydro_year, values=2006), hydro_year)) %>% 
  mutate(hydro_year=if_else(year_month == "2006_Oct", replace(x=hydro_year, values=2007), hydro_year)) %>% 
  mutate(hydro_year=if_else(year_month == "2007_Aug", replace(x=hydro_year, values=2008), hydro_year)) %>% 
  mutate(hydro_year=if_else(year_month == "2007_Sep", replace(x=hydro_year, values=2008), hydro_year)) %>%
  mutate(hydro_year=if_else(year_month == "2007_Oct", replace(x=hydro_year, values=2008), hydro_year)) %>% 
  mutate(hydro_year=if_else(year_month == "2008_Oct", replace(x=hydro_year, values=2009), hydro_year)) %>% 
  mutate(hydro_year=if_else(year_month == "2010_Oct", replace(x=hydro_year, values=2011), hydro_year)) %>% 
  mutate(hydro_year=if_else(year_month == "2011_Oct", replace(x=hydro_year, values=2012), hydro_year)) %>% 
  mutate(hydro_year=if_else(year_month == "2012_Oct", replace(x=hydro_year, values=2013), hydro_year)) 

# Crate a data.frame to plot panels corresponding to wet and dry season
rect_idx_season_grp <- cbind(  data.frame(hydro_year=rep(2000:2011, each=2)),
                               data.frame(season=c("Wet","Dry"),stringsAsFactors=F),
                               data.frame(xmin=NA),
                               data.frame(xmax=NA),
                               data.frame(ymin=-Inf),
                               data.frame(ymax=Inf))
rect_idx_season_grp <- rect_idx_season_grp[-1,]

for(n in 1:nrow(rect_idx_season_grp)) {
  print(n)
  rect_idx_season_grp$xmin[n] <- min(metadata_pad_grp[metadata_pad_grp$hydro_year %in% rect_idx_season_grp$hydro_year[n] & metadata_pad_grp$season %in% rect_idx_season_grp$season[n],]$time)
  rect_idx_season_grp$xmax[n] <- max(metadata_pad_grp[metadata_pad_grp$hydro_year %in% rect_idx_season_grp$hydro_year[n] & metadata_pad_grp$season %in% rect_idx_season_grp$season[n],]$time)
}
x_breaks_grp <- rect_idx_season_grp %>% group_by(hydro_year) %>% summarise(min=min(xmin),max=max(xmax))
```

```{r, echo=T, eval=T, message=FALSE, warning=FALSE}
# As each group's time series are pretty much continuous, we impute missing data points  
metadata_pad_grp$PC1_fitted <-NA
metadata_pad_grp$PC1_se.fit <-NA

# You can have a look at each group's fitted smooth by plotting each model object (e.g. plot(m1.1). This will also show you the distribution of samples (the rug above the x-axis).
m1.1 <- mgcv::gam(PC1 ~ s(time, k=40, bs="cc"), data=metadata_pad_grp[metadata_pad_grp$grp %in% "1.1",])
m1.21 <- mgcv::gam(PC1 ~ s(time, k=40, bs="cc"), data=metadata_pad_grp[metadata_pad_grp$grp %in% "1.21",])
m1.22 <- mgcv::gam(PC1 ~ s(time, k=40, bs="cc"), data=metadata_pad_grp[metadata_pad_grp$grp %in% "1.22",])
m2.1 <- mgcv::gam(PC1 ~ s(time, k=40, bs="cc"), data=metadata_pad_grp[metadata_pad_grp$grp %in% "2.1",])
m2.2 <- mgcv::gam(PC1 ~ s(time, k=40, bs="cc"), data=metadata_pad_grp[metadata_pad_grp$grp %in% "2.2",])

# Impute missing data points 
for(k in c("1.1","1.21","1.22","2.1","2.2")) {
  print(k)
  metadata_pad_grp[metadata_pad_grp$grp %in% k,]$PC1_fitted <- mgcv::predict.bam(get(paste0("m",k)), newdata=metadata_pad_grp[metadata_pad_grp$grp %in% k,][,c("PC1","time")])
  metadata_pad_grp[metadata_pad_grp$grp %in% k,]$PC1_se.fit <- mgcv::predict.bam(get(paste0("m",k)), se.fit=T, newdata=metadata_pad_grp[metadata_pad_grp$grp %in% k,][,c("PC1","time")])$se.fit
}

# Compute 95% CIs
metadata_pad_grp <- metadata_pad_grp %>% 
  group_by(grp) %>%
  mutate(sample_size=n(), 
         PC1_lower.ci=PC1_fitted - qt(1 - (0.05 / 2), sample_size-1) * PC1_se.fit,
         PC1_upper.ci=PC1_fitted + qt(1 - (0.05 / 2), sample_size-1) * PC1_se.fit)

# Here you can see the effect of the imputation--very similar curves but the one with imputed values is much smoother.
p_1.1a <- gratia::draw(m1.1)
p_1.1b <- metadata_pad_grp %>% 
  filter(grp %in% "1.1") %>%
  filter(hydro_year %in% interval) %>%
  ggplot(aes(y=PC1, x=time)) + 
  geom_ribbon(aes(ymin=PC1_lower.ci, ymax=PC1_upper.ci, group=factor(grp)), fill="#dddbdb", alpha=0.3) +
  geom_line(aes(y=PC1_fitted, x=time, color=factor(grp))) +
  labs(x=NULL, y="PC1") + 
  theme_bw() +
  guides(color=F)

# Plot fitted and imputed smooths
p_1.1a / p_1.1b

# Plot smooths for all groups
p_grp <- metadata_pad_grp %>% 
  #filter(hydro_year %in% interval) %>%
  ggplot(aes(y=PC1, x=time)) + 
  geom_rect(data=rect_idx_season_grp, inherit.aes=FALSE, aes(xmin=xmin, xmax=xmax, ymin=ymin, ymax=ymax, fill=factor(season)), alpha=0.7, show.legend=F) + 
  scale_fill_manual(values = c("#f6e8c3","#7fbf7b")) +
  geom_ribbon(aes(ymin=PC1_lower.ci, ymax=PC1_upper.ci, group=factor(grp)), fill="#dddbdb", alpha=0.3) +
  geom_line(aes(y=PC1_fitted, x=time, color=factor(grp))) +
  labs(x=NULL, y="PC1") + 
  scale_x_continuous(breaks=x_breaks_grp$min, labels=x_breaks_grp$hydro_year, expand=c(0, 0)) +  
  theme(panel.grid.major=element_blank(), 
        panel.grid.minor=element_blank(),
        panel.background=element_blank(), 
        axis.ticks.length=unit(0.25,"cm"), 
        axis.text.x=element_text(size=10),
        legend.position="bottom", legend.box="horizontal") +
  scale_color_manual(values=setNames(c("#e41a1c","#f28106","#4745af","#e541c6","#31725b"), c("1.1","1.21","1.22","2.1","2.2"))) +
  guides(color=guide_legend(title="Social groups"))

# Plot it
p_grp
```


## Host level dynamics
```{r, echo=T, eval=T, message=FALSE, warning=FALSE}
# Our 13 best-sampled hosts
select_host <- c("Baboon_498","Baboon_103","Baboon_494","Baboon_503","Baboon_4","Baboon_390","Baboon_113","Baboon_283","Baboon_395","Baboon_382","Baboon_481","Baboon_107","Baboon_78")

# Subset data
metadata_host <- metadata %>%
  filter(host %in% select_host) %>%
  mutate(host=factor(host))

# As each individual host has quite large gaps in their time series, we fit the GAMs without imputing missing data points to more transparently show how data looks like. If you did impute the missing data points the smooths would be much smoother. Lastly, instead of showing CIs here, we dash line segments between two samples if the gap >= 100 days.

metadata_host$PC1_fitted <- NA
metadata_host$PC1_se.fit <- NA

for(l in select_host){
  print(l)
  metadata_host[metadata_host$host %in% l,]$PC1_fitted <- broom::augment(mgcv::gam(PC1 ~ s(time, k=25, bs="cc"), data=metadata_host[metadata_host$host %in% l,]))$.fitted
  metadata_host[metadata_host$host %in% l,]$PC1_se.fit <- broom::augment(mgcv::gam(PC1 ~ s(time, k=25, bs="cc"), data=metadata_host[metadata_host$host %in% l,]))$.se.fit
}
metadata_host <- metadata_host %>% 
  mutate(sample_size=n(),
         lower.ci = PC1_fitted - qt(1 - (0.05 / 2), sample_size - 1) * PC1_se.fit,
         upper.ci = PC1_fitted + qt(1 - (0.05 / 2), sample_size - 1) * PC1_se.fit)

# The below chunk of code re-arranges the data making it possible to dash segments of each host's time series that represent a gap between two samples >= 100 days.
num.hosts <- length(select_host)
windows <- vector("list", num.hosts)
names(windows) <- select_host

for(k in select_host) {
  print(k)
  tmp <- metadata_host[metadata_host$host==k,]
  bins <- seq(from=1, to=length(tmp[!is.na(tmp$time),]$time), by=1)
  tmp_ls <- vector("list",length(bins)-1)
  names(tmp_ls) <- 2:max(bins)
  
  for(i in 2:max(bins)) { 
    tmp_ls[names(tmp_ls)==i][[1]] <- (bins[i]-1):bins[i]
  }
  windows[names(windows)==k][[1]] <- tmp_ls
}

hosts_ls <- vector("list", num.hosts)
names(hosts_ls) <- select_host

for(kk in select_host) {
  print(kk)
  wdw <- windows[names(windows)==kk][[1]]
  tmp_ls2 <- vector("list", length(wdw))
  tmp2 <- metadata_host[metadata_host$host==kk,]
  tmp2 <- tmp2 %>%
    mutate(day_diff=abs(collection_date-lag(collection_date)),
           threshold=case_when(day_diff<100~"below", day_diff>100~"above"))

  for(n in 1:length(wdw)) {
    if( is.na(tmp2[wdw[[n]],]$day_diff[2]) ) { next }
    else if( tmp2[wdw[[n]],]$day_diff[2] > 100 ) {
      tmp_ls2[[n]] <- tmp2[wdw[[n]],]
      tmp_ls2[[n]]$type <- "A"
      tmp_ls2[[n]]$window <- n
    } else {
        tmp_ls2[[n]] <- tmp2[wdw[[n]],]
        tmp_ls2[[n]]$type <- "B"
        tmp_ls2[[n]]$window <- n
    }
  }
  hosts_ls[names(hosts_ls)==kk][[1]] <- tmp_ls2
}

metadata_host_updated <- do.call(rbind, do.call(Map, c(f=rbind, hosts_ls))) 

metadata_host_updated <- metadata_host_updated %>%
  arrange(time) %>%
  padr::pad(by="collection_date") %>%
  mutate(time=as.integer(factor(collection_date)))

host_cols <- sample(x=c('#08abf4','#14e2d3','#83ba4f','#33a02c','#fb9a99','#e31a1c','#c49158','#ff7f00','#d354b5','#6a3d9a','#f6e002','#7f5745','darkgray'), size=13)
host_cols <- setNames(host_cols,select_host)

p_host <- metadata_host_updated %>% 
  ggplot(aes(x=time, y=PC1_fitted, group=interaction(host, window))) + 
  geom_rect(data=rect_idx_season, inherit.aes=FALSE, aes(xmin=xmin, xmax=xmax, ymin=ymin, ymax=ymax, fill=factor(season)), alpha=0.7, show.legend=F) + 
  scale_fill_manual(values=c("#f6e8c3","#7fbf7b")) +
  geom_line(aes(linetype=type, color=host, alpha=type), size=0.8) + 
  scale_linetype_manual(values=c("dashed","solid")) +
  scale_color_manual(values=host_cols) +
  scale_x_continuous(breaks=x_breaks$min, labels=x_breaks$hydro_year, expand=c(0, 0)) +  
  guides(color=guide_legend(title="Hosts"), fill=FALSE, linetype=FALSE, alpha=FALSE) + 
  theme(panel.grid.major=element_blank(), 
        panel.grid.minor=element_blank(),
        panel.background=element_blank(), 
        axis.ticks.length=unit(0.25,"cm"), 
        axis.text.x=element_text(size=10)) +
  xlab("Hydrological year") + ylab("PC1") + 
  scale_alpha_manual(values = c(0.6, 1))

# Plot it
p_host 
```



### Populaion + Group + Host
```{r, echo=T, eval=T, message=FALSE, warning=FALSE}
# Plot all levels together restricting the data to 2000:2011
p_pop_short <- metadata_pad %>% 
  filter(hydro_year %in% 2000:2011) %>%
  ggplot(aes(y=PC1, x=time)) +
  geom_rect(data=rect_idx_season_grp, inherit.aes=FALSE, aes(xmin=xmin, xmax=xmax, ymin=ymin, ymax=ymax, fill=factor(season)), alpha=0.7, show.legend=T) + 
  scale_fill_manual(values = c("#f6e8c3","#7fbf7b")) +
  geom_point(aes(color=factor(season)), size=0.7, alpha=0.5) + 
  scale_color_manual(values = c("#c6c3c1","#efe3d8")) +
  geom_ribbon(aes(ymin=PC1_lower.ci, ymax=PC1_upper.ci), fill="#dddbdb", alpha=0.3) + 
  geom_line(aes(y=PC1_fitted, x=time), color="#ef9050") + 
  xlab(NULL) + 
  ylab("PC1") +
  scale_x_continuous(breaks=x_breaks_grp$min, labels=x_breaks_grp$hydro_year, expand=c(0,0)) +
  theme(panel.grid.major=element_blank(), 
        panel.grid.minor = element_blank(),
        panel.background=element_blank(), 
        axis.ticks.length=unit(0.25,"cm"), 
        axis.title.y=element_text(size=11), 
        axis.title.x=element_text(size=11), 
        axis.text.y=element_text(size=10), 
        axis.text.x=element_text(size=10), 
        axis.line=element_blank(),
        legend.position="bottom", legend.box="horizontal") +
  guides(color=F, fill=guide_legend(title="Season"))

p_host_short <- metadata_host_updated %>% 
  filter(hydro_year %in% 2000:2011) %>%
  ggplot(aes(x=time, y=PC1_fitted, group=interaction(host, window))) + 
  geom_rect(data=rect_idx_season_grp, inherit.aes=FALSE, aes(xmin=xmin, xmax=xmax, ymin=ymin, ymax=ymax, fill=factor(season)), alpha=0.7, show.legend=F) + 
  scale_fill_manual(values=c("#f6e8c3","#7fbf7b")) +
  geom_line(aes(linetype=type, color=host, alpha=type), size=0.8) + 
  scale_linetype_manual(values=c("dashed","solid")) +
  scale_color_manual(values=host_cols) +
  scale_x_continuous(breaks=x_breaks_grp$min, labels=x_breaks_grp$hydro_year, expand=c(0, 0)) +  
  guides(color=guide_legend(title="Hosts"), fill=FALSE, linetype=FALSE, alpha=FALSE) + 
  theme(panel.grid.major=element_blank(), 
        panel.grid.minor=element_blank(),
        panel.background=element_blank(), 
        axis.ticks.length=unit(0.25,"cm"), 
        axis.text.x=element_text(size=10),
        legend.position="bottom", legend.box="horizontal") +
  xlab("Hydrological year") + ylab("PC1") + 
  scale_alpha_manual(values = c(0.6, 1))

# Plot using patchwork
p_pop_short / p_grp / p_host_short
```